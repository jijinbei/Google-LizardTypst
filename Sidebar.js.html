<script type="module">
    // 1. import $typst from the all-in-one library
    import { $typst } from "https://cdn.jsdelivr.net/npm/@myriaddreamin/typst-all-in-one.ts@0.6.0/dist/esm/index.js";

    const statusEl = document.getElementById("status");
    const input = document.getElementById("code");
    const previewBox = document.getElementById("preview-box");
    const insertBtn = document.getElementById("insertBtn");
    const errorLogEl = document.getElementById("error-log");
    const historyList = document.getElementById("history-list");
    const imageWidthInput = document.getElementById("image-width-input");
    const widthUpBtn = document.getElementById("width-up-btn");
    const widthDownBtn = document.getElementById("width-down-btn");

    const MAX_HISTORY_LENGTH = 20;
    let equationHistory = [];
    const defaultCode = `#set page(
  width: auto,
  height: auto,
  margin: .2cm,
  fill: none,
)
$
  sum_(k=1)^n k = (n(n+1))/2
$`;

    function setStatus(msg, isError) {
        statusEl.textContent = msg;
        statusEl.className = isError ? "status-error" : "";
    }

    // 2. compile function
    const compile = async (mainContent) => {
        try {
            const svg = await $typst.svg({ mainContent });
            previewBox.innerHTML = svg;
            errorLogEl.style.display = "none"; // Hide error log on success
            errorLogEl.textContent = "";

            // Enlarge the preview SVG to fit the container width
            const svgElement = previewBox.querySelector("svg");
            if (svgElement) {
                svgElement.style.width = "100%";
                svgElement.style.height = "auto";
            }

            setStatus("Preview updated", false);
            insertBtn.disabled = false;
        } catch (e) {
            console.error(e); // Keep this for debugging
            setStatus("Compilation failed", true);
            insertBtn.disabled = true;
            previewBox.innerHTML = ""; // Clear preview on error

            // Format and display the error
            errorLogEl.style.display = "block";
            let formattedError = "";
            const isString = typeof e === "string" || e instanceof String;

            if (isString) {
                formattedError = parseDiagnostic(e);
            } else if (e && e.message) {
                // Handle standard Error objects, which might wrap the diagnostic string
                formattedError = parseDiagnostic(e.message);
            } else {
                // Fallback for completely unknown errors
                formattedError = "An unknown error occurred.";
                try {
                    formattedError += `<br><pre style="font-size: 10px; white-space: pre-wrap;">${escapeHtml(JSON.stringify(e, null, 2))}</pre>`;
                } catch (stringifyError) {
                    // Ignore if stringify fails
                }
            }
            errorLogEl.innerHTML = formattedError;
        }
    };

    function escapeHtml(unsafe) {
        if (unsafe === null || unsafe === undefined) return "";
        return unsafe
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&#039;");
    }

    function parseDiagnostic(diagnosticString) {
        if (
            !diagnosticString ||
            !diagnosticString.includes("SourceDiagnostic")
        ) {
            return `<pre style="white-space: pre-wrap;">${escapeHtml(diagnosticString)}</pre>`;
        }

        try {
            const messageMatch = diagnosticString.match(/message:\s*"(.*?)"/s);
            const hintsMatch = diagnosticString.match(/hints:\s*(\[.*?\])/s);

            let errorContent = "";
            if (messageMatch && messageMatch[1]) {
                errorContent += `<div><span class="error-title">Error:</span> ${escapeHtml(messageMatch[1])}</div>`;
            }

            if (hintsMatch && hintsMatch[1]) {
                const hintsArray = JSON.parse(hintsMatch[1]);
                const hintsHtml = hintsArray
                    .map(
                        (hint) =>
                            `<div style="padding-left: 15px;"><span class="hint-title">Hint:</span> ${escapeHtml(hint)}</div>`,
                    )
                    .join("");
                errorContent += hintsHtml;
            }

            if (errorContent) {
                return `<div style="margin-bottom: 10px;">${errorContent}</div>`;
            }
        } catch (parseError) {
            console.error("Failed to parse diagnostic string:", parseError);
        }

        // Fallback for any failure
        return `<pre style="white-space: pre-wrap;">${escapeHtml(diagnosticString)}</pre>`;
    }

    function extractDollarContent(text) {
        const match = text.match(/\$(.*?)\$/s);
        return match ? match[1].trim() : null;
    }

    function renderHistory() {
        historyList.innerHTML = "";
        equationHistory.forEach((equation) => {
            const li = document.createElement("li");
            const dollarContent = extractDollarContent(equation);
            li.textContent = dollarContent || equation;
            li.dataset.equation = equation; // Store full equation
            historyList.appendChild(li);
        });
    }

    function loadHistory() {
        const storedHistory = localStorage.getItem("equationHistory");
        if (storedHistory) {
            equationHistory = JSON.parse(storedHistory);
            renderHistory();
        }
    }

    function saveHistory(equation) {
        // Avoid duplicates by removing existing entry first
        equationHistory = equationHistory.filter((item) => item !== equation);
        // Add to the beginning of the array
        equationHistory.unshift(equation);
        // Trim to max length
        if (equationHistory.length > MAX_HISTORY_LENGTH) {
            equationHistory = equationHistory.slice(0, MAX_HISTORY_LENGTH);
        }
        // Save to localStorage
        localStorage.setItem(
            "equationHistory",
            JSON.stringify(equationHistory),
        );
        renderHistory();
    }

    // initialize
    try {
        input.addEventListener("input", () => compile(input.value));

        input.value = defaultCode;
        loadHistory();
        await compile(input.value);
    } catch (e) {
        setStatus("Initialization error: " + e.message, true);
    }

    // 3. Image insertion process (SVG -> Canvas -> PNG -> GAS)
    insertBtn.addEventListener("click", () => {
        const svgElement = previewBox.querySelector("svg");
        if (!svgElement) return;

        saveHistory(input.value);

        insertBtn.disabled = true;
        insertBtn.textContent = "Processing...";

        let desiredWidth = parseInt(imageWidthInput.value, 10);
        if (isNaN(desiredWidth) || desiredWidth <= 0) {
            desiredWidth = null;
        }

        const viewBox = svgElement
            .getAttribute("viewBox")
            .split(" ")
            .map(parseFloat);
        const w = viewBox[2];
        const h = viewBox[3];

        // Dynamically calculate scale for better resolution on larger images.
        // Default to 4x if no width is given. Otherwise, aim for ~3px per point, but clamp between 1x and 10x.
        const scale =
            desiredWidth && w > 0
                ? Math.min(10, Math.max(1, (desiredWidth * 3) / w))
                : 4;

        const canvas = document.createElement("canvas");
        canvas.width = w * scale;
        canvas.height = h * scale;
        const ctx = canvas.getContext("2d");

        const s = new XMLSerializer().serializeToString(svgElement);
        const encodedData = window.btoa(unescape(encodeURIComponent(s)));
        const img = new Image();

        img.onload = () => {
            ctx.scale(scale, scale);
            ctx.drawImage(img, 0, 0);
            const pngData = canvas.toDataURL("image/png");

            google.script.run
                .withSuccessHandler(() => {
                    insertBtn.disabled = false;
                    insertBtn.textContent = "Insert";
                    setStatus("Insertion complete", false);
                })
                .withFailureHandler((e) => {
                    alert("Error: " + e);
                    insertBtn.disabled = false;
                })
                .insertImageToSlide(pngData, desiredWidth);
        };

        img.src = "data:image/svg+xml;base64," + encodedData;
    });

    widthUpBtn.addEventListener("click", () => {
        imageWidthInput.stepUp();
    });

    widthDownBtn.addEventListener("click", () => {
        imageWidthInput.stepDown();
    });

    historyList.addEventListener("mouseover", (e) => {
        if (e.target.tagName === "LI") {
            const equation = e.target.dataset.equation;
            if (equation) {
                compile(equation);
            }
        }
    });

    historyList.addEventListener("mouseout", (e) => {
        // Revert to the current editor content for preview
        compile(input.value);
    });

    historyList.addEventListener("click", (e) => {
        if (e.target.tagName === "LI") {
            const equation = e.target.dataset.equation;
            if (equation) {
                input.value = equation;
                compile(equation); // Update preview as well
            }
        }
    });
</script>
